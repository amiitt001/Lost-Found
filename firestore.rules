rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Items collection: restrict visibility for FOUND items until a match is detected
    match /items/{itemId} {
      // Get (single document): enforce strict visibility
      allow get: if (
        (request.auth != null && exists(/databases/$(database)/documents/admins/$(request.auth.uid)))
        || (resource.data.type != 'FOUND')
        || (request.auth != null && request.auth.uid == resource.data.userId)
        || ((resource.data.matchConfidence is number) && resource.data.matchConfidence > 0.1)
      );

      // List (queries): restrict listing so clients cannot retrieve FOUND items unless
      // - the query explicitly filters out FOUND (e.g. `where('type', '!=', 'FOUND')`), or
      // - the query is for the current user's items (owner), or
      // - the query asks only for high-confidence matches (matchConfidence > 0.1).
      // NOTE: Firestore rules can inspect the query constraints via request.query.
      allow list: if request.auth != null && (
        // query excludes FOUND items
        request.query.where('type', '!=', 'FOUND')
        // OR query is asking for items owned by the requesting user
        || request.query.where('userId', '==', request.auth.uid)
        // OR query is asking only for sufficiently confident matches
        || request.query.where('matchConfidence', '>', 0.1)
      );

      // Only authenticated users can create items and userId must match auth.uid
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0;

      // Only owner can update or delete
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Users collection (store fcmToken and minimal profile info)
    match /users/{userId} {
      // Allow users to read their own document
      allow read: if request.auth != null && request.auth.uid == userId;

      // Allow creating/updating only by the user themself.
      // If `fcmTokens` is provided it must be a list. This also allows update operations
      // that use arrayUnion/arrayRemove transforms because we only validate when the field is present.
      allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && (
                                (!request.resource.data.keys().hasAny(['fcmTokens']))
                                || (request.resource.data.fcmTokens is list)
                              );

      // Do not allow delete via client
      allow delete: if false;
    }

    // Admins collection: allow a user to read their own admin marker document to check admin status
    match /admins/{adminId} {
      allow read: if request.auth != null && request.auth.uid == adminId;
      allow create: if false;
      allow update, delete: if false;
    }

    // Conversations collection
    match /conversations/{convId} {
      // Create: must be authenticated and include the current user in participants
      allow create: if request.auth != null
                    && request.resource.data.participants is list
                    && request.auth.uid in request.resource.data.participants
                    && request.resource.data.itemId is string;

      // Get a conversation only if the requester is a participant
      allow get: if request.auth != null && request.auth.uid in resource.data.participants;

      // Allow listing conversations only for authenticated users (client should filter by participant)
      allow list: if request.auth != null;

      // Disallow arbitrary updates/deletes to conversation metadata (or restrict to participants)
      allow update, delete: if request.auth != null && request.auth.uid in resource.data.participants;

      // Messages subcollection rules
      match /messages/{messageId} {
        // Only participants may read messages; enforce by checking parent conversation
        allow read: if request.auth != null &&
              (request.auth.uid in get(/databases/$(database)/documents/conversations/$(convId)).data.participants);

        // Create message only if authenticated and senderId matches auth.uid and text is non-empty
        allow create: if request.auth != null
                      && request.resource.data.senderId == request.auth.uid
                      && request.resource.data.text is string
                      && request.resource.data.text.size() > 0;

        // Updates: allow admins full update; participants may update only non-moderation fields.
        // Prevent participants from resolving flags or unflagging messages.
        allow update: if request.auth != null && (
          // admin can update anything
          exists(/databases/$(database)/documents/admins/$(request.auth.uid))
          // participants can update (non-moderation changes) â€” do not allow them to set flaggedResolved* or to clear flagged
          || (
            request.auth.uid in get(/databases/$(database)/documents/conversations/$(convId)).data.participants
            && !request.resource.data.keys().hasAny(['flaggedResolvedAt', 'flaggedResolvedBy'])
            && !(request.resource.data.keys().hasAny(['flagged']) && request.resource.data.flagged == false)
          )
        );

        // Delete: allow admin to delete any message. Allow sender to delete their message only if it is not currently flagged.
        allow delete: if request.auth != null && (
          exists(/databases/$(database)/documents/admins/$(request.auth.uid))
          || (request.auth.uid == resource.data.senderId && (resource.data.flagged != true))
        );
      }
    }

    // Fallback: deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
