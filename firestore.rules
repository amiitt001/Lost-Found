rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Public items collection
    match /items/{itemId} {
      // Anyone can read items
      allow read: if true;

      // Only authenticated users can create items and userId must match auth.uid
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0;

      // Only owner can update or delete
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Users collection (store fcmToken and minimal profile info)
    match /users/{userId} {
      // Allow users to read their own document
      allow read: if request.auth != null && request.auth.uid == userId;

      // Allow creating/updating only by the user themself and restrict writes to fcmToken field
      allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && (
                                // allow writing fcmToken (string or null)
                                (request.resource.data.keys().hasOnly(['fcmToken']) && (request.resource.data.fcmToken is string || request.resource.data.fcmToken == null))
                              );

      // Do not allow delete via client
      allow delete: if false;
    }

    // Conversations collection
    match /conversations/{convId} {
      // Create: must be authenticated and include the current user in participants
      allow create: if request.auth != null
                    && request.resource.data.participants is list
                    && request.auth.uid in request.resource.data.participants
                    && request.resource.data.itemId is string;

      // Get a conversation only if the requester is a participant
      allow get: if request.auth != null && request.auth.uid in resource.data.participants;

      // Allow listing conversations only when client queries with array-contains for the auth user
      allow list: if request.auth != null
                  && request.query.where('participants', 'array-contains', request.auth.uid);

      // Disallow arbitrary updates/deletes to conversation metadata (or restrict to participants)
      allow update, delete: if request.auth != null && request.auth.uid in resource.data.participants;

      // Messages subcollection rules
      match /messages/{messageId} {
        // Only participants may read messages; enforce by checking parent conversation
        allow read: if request.auth != null &&
                    (get(/databases/$(database)/documents/conversations/$(convId)).data.participants hasAny [request.auth.uid]);

        // Create message only if authenticated and senderId matches auth.uid and text is non-empty
        allow create: if request.auth != null
                      && request.resource.data.senderId == request.auth.uid
                      && request.resource.data.text is string
                      && request.resource.data.text.size() > 0;

        // Updates: allow admins full update; participants may update only non-moderation fields.
        // Prevent participants from resolving flags or unflagging messages.
        allow update: if request.auth != null && (
          // admin can update anything
          exists(/databases/$(database)/documents/admins/$(request.auth.uid))
          // participants can update (non-moderation changes) â€” do not allow them to set flaggedResolved* or to clear flagged
          || (
            request.auth.uid in get(/databases/$(database)/documents/conversations/$(convId)).data.participants
            && !request.resource.data.keys().hasAny(['flaggedResolvedAt', 'flaggedResolvedBy'])
            && !(request.resource.data.keys().hasAny(['flagged']) && request.resource.data.flagged == false)
          )
        );

        // Delete: allow admin to delete any message. Allow sender to delete their message only if it is not currently flagged.
        allow delete: if request.auth != null && (
          exists(/databases/$(database)/documents/admins/$(request.auth.uid))
          || (request.auth.uid == resource.data.senderId && (resource.data.flagged != true))
        );
      }
    }

    // Fallback: deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
